NoiseCodec	libp2p/protocols/secure/noise.html#NoiseCodec	noise: NoiseCodec	
Noise	libp2p/protocols/secure/noise.html#Noise	noise: Noise	
NoiseConnection	libp2p/protocols/secure/noise.html#NoiseConnection	noise: NoiseConnection	
NoiseError	libp2p/protocols/secure/noise.html#NoiseError	noise: NoiseError	
NoiseHandshakeError	libp2p/protocols/secure/noise.html#NoiseHandshakeError	noise: NoiseHandshakeError	
NoiseDecryptTagError	libp2p/protocols/secure/noise.html#NoiseDecryptTagError	noise: NoiseDecryptTagError	
NoiseOversizedPayloadError	libp2p/protocols/secure/noise.html#NoiseOversizedPayloadError	noise: NoiseOversizedPayloadError	
NoiseNonceMaxError	libp2p/protocols/secure/noise.html#NoiseNonceMaxError	noise: NoiseNonceMaxError	
shortLog	libp2p/protocols/secure/noise.html#shortLog,NoiseConnection	noise: shortLog(conn: NoiseConnection): auto	
formatItIMPL	libp2p/protocols/secure/noise.html#formatItIMPL.t,NoiseConnection	noise: formatItIMPL(it: NoiseConnection): auto	
readMessage	libp2p/protocols/secure/noise.html#readMessage.e,NoiseConnection	noise: readMessage(sconn: NoiseConnection): Future[seq[byte]]	
write	libp2p/protocols/secure/noise.html#write.e,NoiseConnection,seq[byte]	noise: write(sconn: NoiseConnection; message: seq[byte]): Future[void]	
handshake	libp2p/protocols/secure/noise.html#handshake.e,Noise,Connection,bool	noise: handshake(p: Noise; conn: Connection; initiator: bool): Future[SecureConn]	
closeImpl	libp2p/protocols/secure/noise.html#closeImpl.e,NoiseConnection	noise: closeImpl(s: NoiseConnection): Future[void]	
init	libp2p/protocols/secure/noise.html#init.e,Noise	noise: init(p: Noise)	
new	libp2p/protocols/secure/noise.html#new,typedesc[Noise],ref.HmacDrbgContext,PrivateKey,bool,seq[byte]	noise: new(T: typedesc[Noise]; rng: ref BrHmacDrbgContext; privateKey: PrivateKey;\n    outgoing: bool = true; commonPrologue: seq[byte] = @[]): T:type	
