{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"tutorial_1_connect/","text":"Simple ping tutorial Hi all, welcome to the first article of the nim-libp2p's tutorial series! This tutorial is for everyone who is interested in building peer-to-peer chatting applications. No Nim programming experience is needed. To give you a quick overview, Nim is the programming language we are using and nim-libp2p is the Nim implementation of libp2p , a modular library that enables the development of peer-to-peer network applications. Hope you'll find it helpful in your journey of learning. Happy coding! ;) Before you start The only prerequisite here is Nim , the programming language with a Python-like syntax and a performance similar to C. Detailed information can be found here . Install Nim via their official website: https://nim-lang.org/install.html Check Nim's installation via nim --version and its package manager Nimble via nimble --version . You can now install the latest version of nim-libp2p : nimble install libp2p@#master A simple ping application We'll start by creating a simple application, which is starting two libp2p switch , and pinging each other using the Ping protocol. You can extract the code from this tutorial by running nim c -r tools/markdown_runner.nim examples/tutorial_1_connect.md in the libp2p folder! Let's create a part1.nim , and import our dependencies: import chronos import libp2p import libp2p / protocols / ping chronos the asynchronous framework used by nim-libp2p Next, we'll create an helper procedure to create our switches. A switch needs a bit of configuration, and it will be easier to do this configuration only once: proc createSwitch ( ma : MultiAddress , rng : ref HmacDrbgContext ): Switch = var switch = SwitchBuilder . new () . withRng ( rng ) # Give the application RNG . withAddress ( ma ) # Our local address(es) . withTcpTransport () # Use TCP as transport . withMplex () # Use Mplex as muxer . withNoise () # Use Noise as secure manager . build () return switch This will create a switch using Mplex as a multiplexer, Noise to secure the communication, and TCP as an underlying transport. You can of course tweak this, to use a different or multiple transport, or tweak the configuration of Mplex and Noise, but this is some sane defaults that we'll use going forward. Let's now start to create our main procedure: proc main () {. async , gcsafe .} = let rng = newRng () localAddress = MultiAddress . init ( \"/ip4/0.0.0.0/tcp/0\" ). tryGet () pingProtocol = Ping . new ( rng = rng ) We created some variables that we'll need for the rest of the application: the global rng instance, our localAddress , and an instance of the Ping protocol. The address is in the MultiAddress format. The port 0 means \"take any port available\". tryGet is procedure which is part of nim-result , that will throw an exception if the supplied MultiAddress is invalid. We can now create our two switches: let switch1 = createSwitch ( localAddress , rng ) switch2 = createSwitch ( localAddress , rng ) switch1 . mount ( pingProtocol ) await switch1 . start () await switch2 . start () We've mounted the pingProtocol on our first switch. This means that the first switch will actually listen for any ping requests coming in, and handle them accordingly. Now that we've started the nodes, they are listening for incoming peers. We can find out which port was attributed, and the resulting local addresses, by using switch1.peerInfo.addrs . We'll dial the first switch from the second one, by specifying it's Peer ID , it's MultiAddress and the Ping protocol codec : let conn = await switch2 . dial ( switch1 . peerInfo . peerId , switch1 . peerInfo . addrs , PingCodec ) We now have a Ping connection setup between the second and the first switch, we can use it to actually ping the node: # ping the other node and echo the ping duration echo \"ping: \" , await pingProtocol . ping ( conn ) # We must close the connection ourselves when we're done with it await conn . close () And that's it! Just a little bit of cleanup: shutting down the switches, waiting for them to stop, and we'll call our main procedure: await allFutures ( switch1 . stop (), switch2 . stop ()) # close connections and shutdown all transports waitFor ( main ()) You can now run this program using nim c -r part1.nim , and you should see the dialing sequence, ending with a ping output. In the next tutorial , we'll look at how to create our own custom protocol.","title":"Part I: Simple connection"},{"location":"tutorial_1_connect/#simple-ping-tutorial","text":"Hi all, welcome to the first article of the nim-libp2p's tutorial series! This tutorial is for everyone who is interested in building peer-to-peer chatting applications. No Nim programming experience is needed. To give you a quick overview, Nim is the programming language we are using and nim-libp2p is the Nim implementation of libp2p , a modular library that enables the development of peer-to-peer network applications. Hope you'll find it helpful in your journey of learning. Happy coding! ;)","title":"Simple ping tutorial"},{"location":"tutorial_1_connect/#before-you-start","text":"The only prerequisite here is Nim , the programming language with a Python-like syntax and a performance similar to C. Detailed information can be found here . Install Nim via their official website: https://nim-lang.org/install.html Check Nim's installation via nim --version and its package manager Nimble via nimble --version . You can now install the latest version of nim-libp2p : nimble install libp2p@#master","title":"Before you start"},{"location":"tutorial_1_connect/#a-simple-ping-application","text":"We'll start by creating a simple application, which is starting two libp2p switch , and pinging each other using the Ping protocol. You can extract the code from this tutorial by running nim c -r tools/markdown_runner.nim examples/tutorial_1_connect.md in the libp2p folder! Let's create a part1.nim , and import our dependencies: import chronos import libp2p import libp2p / protocols / ping chronos the asynchronous framework used by nim-libp2p Next, we'll create an helper procedure to create our switches. A switch needs a bit of configuration, and it will be easier to do this configuration only once: proc createSwitch ( ma : MultiAddress , rng : ref HmacDrbgContext ): Switch = var switch = SwitchBuilder . new () . withRng ( rng ) # Give the application RNG . withAddress ( ma ) # Our local address(es) . withTcpTransport () # Use TCP as transport . withMplex () # Use Mplex as muxer . withNoise () # Use Noise as secure manager . build () return switch This will create a switch using Mplex as a multiplexer, Noise to secure the communication, and TCP as an underlying transport. You can of course tweak this, to use a different or multiple transport, or tweak the configuration of Mplex and Noise, but this is some sane defaults that we'll use going forward. Let's now start to create our main procedure: proc main () {. async , gcsafe .} = let rng = newRng () localAddress = MultiAddress . init ( \"/ip4/0.0.0.0/tcp/0\" ). tryGet () pingProtocol = Ping . new ( rng = rng ) We created some variables that we'll need for the rest of the application: the global rng instance, our localAddress , and an instance of the Ping protocol. The address is in the MultiAddress format. The port 0 means \"take any port available\". tryGet is procedure which is part of nim-result , that will throw an exception if the supplied MultiAddress is invalid. We can now create our two switches: let switch1 = createSwitch ( localAddress , rng ) switch2 = createSwitch ( localAddress , rng ) switch1 . mount ( pingProtocol ) await switch1 . start () await switch2 . start () We've mounted the pingProtocol on our first switch. This means that the first switch will actually listen for any ping requests coming in, and handle them accordingly. Now that we've started the nodes, they are listening for incoming peers. We can find out which port was attributed, and the resulting local addresses, by using switch1.peerInfo.addrs . We'll dial the first switch from the second one, by specifying it's Peer ID , it's MultiAddress and the Ping protocol codec : let conn = await switch2 . dial ( switch1 . peerInfo . peerId , switch1 . peerInfo . addrs , PingCodec ) We now have a Ping connection setup between the second and the first switch, we can use it to actually ping the node: # ping the other node and echo the ping duration echo \"ping: \" , await pingProtocol . ping ( conn ) # We must close the connection ourselves when we're done with it await conn . close () And that's it! Just a little bit of cleanup: shutting down the switches, waiting for them to stop, and we'll call our main procedure: await allFutures ( switch1 . stop (), switch2 . stop ()) # close connections and shutdown all transports waitFor ( main ()) You can now run this program using nim c -r part1.nim , and you should see the dialing sequence, ending with a ping output. In the next tutorial , we'll look at how to create our own custom protocol.","title":"A simple ping application"},{"location":"tutorial_2_customproto/","text":"Custom protocol in libp2p In the previous tutorial , we've looked at how to create a simple ping program using the nim-libp2p . We'll now look at how to create a custom protocol inside the libp2p Let's create a part2.nim , and import our dependencies: import chronos import stew / byteutils import libp2p This is similar to the first tutorial, except we don't need to import the Ping protocol. Next, we'll declare our custom protocol const TestCodec = \"/test/proto/1.0.0\" type TestProto = ref object of LPProtocol We've set a protocol ID , and created a custom LPProtocol . In a more complex protocol, we could use this structure to store interesting variables. A protocol generally has two part: and handling/server part, and a dialing/client part. Theses two parts can be identical, but in our trivial protocol, the server will wait for a message from the client, and the client will send a message, so we have to handle the two cases separately. Let's start with the server part: proc new ( T : typedesc [ TestProto ] ): T = # every incoming connections will in be handled in this closure proc handle ( conn : Connection , proto : string ) {. async , gcsafe .} = # Read up to 1024 bytes from this connection, and transform them into # a string echo \"Got from remote - \" , string . fromBytes ( await conn . readLp ( 1024 )) # We must close the connections ourselves when we're done with it await conn . close () return T ( codecs : @[ TestCodec ] , handler : handle ) This is a constructor for our TestProto , that will specify our codecs and a handler , which will be called for each incoming peer asking for this protocol. In our handle, we simply read a message from the connection and echo it. We can now create our client part: proc hello ( p : TestProto , conn : Connection ) {. async .} = await conn . writeLp ( \"Hello p2p!\" ) Again, pretty straight-forward, we just send a message on the connection. We can now create our main procedure: proc main () {. async , gcsafe .} = let rng = newRng () testProto = TestProto . new () switch1 = newStandardSwitch ( rng = rng ) switch2 = newStandardSwitch ( rng = rng ) switch1 . mount ( testProto ) await switch1 . start () await switch2 . start () let conn = await switch2 . dial ( switch1 . peerInfo . peerId , switch1 . peerInfo . addrs , TestCodec ) await testProto . hello ( conn ) # We must close the connection ourselves when we're done with it await conn . close () await allFutures ( switch1 . stop (), switch2 . stop ()) # close connections and shutdown all transports This is very similar to the first tutorial's main , the only noteworthy difference is that we use newStandardSwitch , which is similar to the createSwitch of the first tutorial, but is bundled directly in libp2p We can now wrap our program by calling our main proc: waitFor ( main ()) And that's it!","title":"Part II: Custom protocol"},{"location":"tutorial_2_customproto/#custom-protocol-in-libp2p","text":"In the previous tutorial , we've looked at how to create a simple ping program using the nim-libp2p . We'll now look at how to create a custom protocol inside the libp2p Let's create a part2.nim , and import our dependencies: import chronos import stew / byteutils import libp2p This is similar to the first tutorial, except we don't need to import the Ping protocol. Next, we'll declare our custom protocol const TestCodec = \"/test/proto/1.0.0\" type TestProto = ref object of LPProtocol We've set a protocol ID , and created a custom LPProtocol . In a more complex protocol, we could use this structure to store interesting variables. A protocol generally has two part: and handling/server part, and a dialing/client part. Theses two parts can be identical, but in our trivial protocol, the server will wait for a message from the client, and the client will send a message, so we have to handle the two cases separately. Let's start with the server part: proc new ( T : typedesc [ TestProto ] ): T = # every incoming connections will in be handled in this closure proc handle ( conn : Connection , proto : string ) {. async , gcsafe .} = # Read up to 1024 bytes from this connection, and transform them into # a string echo \"Got from remote - \" , string . fromBytes ( await conn . readLp ( 1024 )) # We must close the connections ourselves when we're done with it await conn . close () return T ( codecs : @[ TestCodec ] , handler : handle ) This is a constructor for our TestProto , that will specify our codecs and a handler , which will be called for each incoming peer asking for this protocol. In our handle, we simply read a message from the connection and echo it. We can now create our client part: proc hello ( p : TestProto , conn : Connection ) {. async .} = await conn . writeLp ( \"Hello p2p!\" ) Again, pretty straight-forward, we just send a message on the connection. We can now create our main procedure: proc main () {. async , gcsafe .} = let rng = newRng () testProto = TestProto . new () switch1 = newStandardSwitch ( rng = rng ) switch2 = newStandardSwitch ( rng = rng ) switch1 . mount ( testProto ) await switch1 . start () await switch2 . start () let conn = await switch2 . dial ( switch1 . peerInfo . peerId , switch1 . peerInfo . addrs , TestCodec ) await testProto . hello ( conn ) # We must close the connection ourselves when we're done with it await conn . close () await allFutures ( switch1 . stop (), switch2 . stop ()) # close connections and shutdown all transports This is very similar to the first tutorial's main , the only noteworthy difference is that we use newStandardSwitch , which is similar to the createSwitch of the first tutorial, but is bundled directly in libp2p We can now wrap our program by calling our main proc: waitFor ( main ()) And that's it!","title":"Custom protocol in libp2p"},{"location":"go-daemon/daemonapi/","text":"Table of Contents Introduction Installation Usage Example Getting Started Introduction This is a libp2p-backed daemon wrapping the functionalities of go-libp2p for use in Nim. For more information about the go daemon, check out this repository . Installation # clone and install dependencies git clone https://github.com/status-im/nim-libp2p cd nim-libp2p nimble install # perform unit tests nimble test # update the git submodule to install the go daemon git submodule update --init --recursive go version git clone https://github.com/libp2p/go-libp2p-daemon cd go-libp2p-daemon git checkout v0.0.1 go install ./... cd .. Usage Example Examples can be found in the examples folder Getting Started Try out the chat example. Full code can be found here : nim c -r --threads:on examples/directchat.nim This will output a peer ID such as QmbmHfVvouKammmQDJck4hz33WvVktNEe7pasxz2HgseRu which you can use in another instance to connect to it. ./examples/directchat /connect QmbmHfVvouKammmQDJck4hz33WvVktNEe7pasxz2HgseRu You can now chat between the instances!","title":"Table of Contents"},{"location":"go-daemon/daemonapi/#table-of-contents","text":"Introduction Installation Usage Example Getting Started","title":"Table of Contents"},{"location":"go-daemon/daemonapi/#introduction","text":"This is a libp2p-backed daemon wrapping the functionalities of go-libp2p for use in Nim. For more information about the go daemon, check out this repository .","title":"Introduction"},{"location":"go-daemon/daemonapi/#installation","text":"# clone and install dependencies git clone https://github.com/status-im/nim-libp2p cd nim-libp2p nimble install # perform unit tests nimble test # update the git submodule to install the go daemon git submodule update --init --recursive go version git clone https://github.com/libp2p/go-libp2p-daemon cd go-libp2p-daemon git checkout v0.0.1 go install ./... cd ..","title":"Installation"},{"location":"go-daemon/daemonapi/#usage","text":"","title":"Usage"},{"location":"go-daemon/daemonapi/#example","text":"Examples can be found in the examples folder","title":"Example"},{"location":"go-daemon/daemonapi/#getting-started","text":"Try out the chat example. Full code can be found here : nim c -r --threads:on examples/directchat.nim This will output a peer ID such as QmbmHfVvouKammmQDJck4hz33WvVktNEe7pasxz2HgseRu which you can use in another instance to connect to it. ./examples/directchat /connect QmbmHfVvouKammmQDJck4hz33WvVktNEe7pasxz2HgseRu You can now chat between the instances!","title":"Getting Started"}]}