TransportError	libp2p/transports/transport.html#TransportError	transport: TransportError	
TransportInvalidAddrError	libp2p/transports/transport.html#TransportInvalidAddrError	transport: TransportInvalidAddrError	
TransportClosedError	libp2p/transports/transport.html#TransportClosedError	transport: TransportClosedError	
Transport	libp2p/transports/transport.html#Transport	transport: Transport	
newTransportClosedError	libp2p/transports/transport.html#newTransportClosedError,ref.Exception	transport: newTransportClosedError(parent: ref Exception = nil): ref LPError	
start	libp2p/transports/transport.html#start.e,Transport,seq[MultiAddress]	transport: start(self: Transport; addrs: seq[MultiAddress]): Future[void]	
stop	libp2p/transports/transport.html#stop.e,Transport	transport: stop(self: Transport): Future[void]	
accept	libp2p/transports/transport.html#accept.e,Transport	transport: accept(self: Transport): Future[Connection]	
dial	libp2p/transports/transport.html#dial.e,Transport,string,MultiAddress	transport: dial(self: Transport; hostname: string; address: MultiAddress): Future[\n    Connection]	
dial	libp2p/transports/transport.html#dial,Transport,MultiAddress	transport: dial(self: Transport; address: MultiAddress): Future[Connection]	
upgradeIncoming	libp2p/transports/transport.html#upgradeIncoming.e,Transport,Connection	transport: upgradeIncoming(self: Transport; conn: Connection): Future[void]	
upgradeOutgoing	libp2p/transports/transport.html#upgradeOutgoing.e,Transport,Connection	transport: upgradeOutgoing(self: Transport; conn: Connection): Future[Connection]	
handles	libp2p/transports/transport.html#handles.e,Transport,MultiAddress	transport: handles(self: Transport; address: MultiAddress): bool	
